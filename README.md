Приведём аналогию с обычной жизненной ситуацией. Пусть в цеху работают два мастера, каждый из которых делает определенную работу с переданной деталью. Например, первый мастер грубо отрезает излишки металла с детали, а второй уже шлифует ее и придает блеск. Пусть цех долго не поставлял детали для мастеров, и тут пришла большая партия, которую нужно сделать. Пока первый мастер не сделает свою работу с деталью, второй мастер не может к ней приступить.

Есть два варианта взаимодействия мастеров:

Во время простоя второй мастер с определенным периодом спрашивает первого мастера, есть ли новые сделанные им детали. Такой подход называется поллингом или опросом.
Какой минус у этого подхода? Нужно постоянно окрикивать живого человека, тратя своё время и его нервы. Думаем, вы уже перевели аналогию с цехом на язык потоков. Поток А (первый мастер) в цикле выполняет определенные действия, затем добавляя детали в разделяемую очередь.

Поток Б (второй мастер) в цикле проверяет длину очереди, и, если там нет деталей, засыпает, чтобы не тратить процессорное время попусту. Но всё равно операционная система вынуждена давать потоку Б процессорное время, чтобы тот проверил очередь, пусть и с каким-то периодом;

Поллинг в программировании — это процесс взаимодействия двух и более выполняемых единиц (потоков, сервисов, серверов), при котором один из них в определённый период производит запрос информации о поступлении новых данных.

Первый мастер окрикивает второго, что тот может забрать деталь для шлифовки. Второй мастер порядочно ждёт события от первого мастера. Тогда на языке потоков это значит, что теперь поток Б не тратит попусту процессорное время, а просыпается лишь, когда действительно появились данные для отработки.

В файле thread sync представлено три возможных реализации описаной программы с использованием трех разных классов для работы с сихонизированной многопоточностью методом 'опроса'
